<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&display=swap" rel="stylesheet">

    <link href="/style/core.css" rel="stylesheet">
    <script src="/core.js"></script>
    
    <meta content="hzFishy.fr" property="og:title" />
    <meta content="About, skills, projects and more." property="og:description" />
    <meta content="https://hzfishy.fr" property="og:url" />
    <meta content="https://hzfishy.fr/data/img/Logo4000_low.jpg" property="og:image" />
    <meta content="#73a39b" data-react-helmet="true" name="theme-color" />
    
    <title>hzFishy - Haze 2nd Impact Project</title>
</head>
<body>
    <div id="top-header-background" style="background-image: linear-gradient(#00000091, #222), url('https://hzfishy.fr/data/img/SwordDancerBackground4.png')">    </div>
    <div id="header"></div>
    
    <div id="img-overlay">
        <img id="overlay-img" src="" alt="">
    </div>
    
    <div id="main-container">
        <div class="center-screen">
            <div class="text-single-container-blur">
                <div class="text-single-container project-single-page-body">
                    <h1>Haze 2nd Impact</h1>
                    <p><b>Group school project | Nov - Jan 2025</b> (~2m)</p>
                    <h2>Key Points</h2>
                    <div class="project-container-content-title-keypoints">
                        <div class="project-container-content-title-keypoints-inner">
                            <p>> Team size: 3 | Unreal Engine 5.6 | C++ & Blueprints</p>
                            <br>
                            <p>> Haze 2nd Impact is a combat game heavily focused on the choreography between an humanoid and a sword.</p>
                            <br>
                            <p>> My responsibilities:</p>
                            <p>&nbsp&nbsp&nbsp- C++ & Blueprint programmer, responsible for the architecture of the project.</p>
                            <p>&nbsp&nbsp&nbsp- Plan, discuss and develop systems and features required following our Game Design documentation.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="project-single-page-body-container">
            <h1>About</h1>
            <p>
               In this project we were 3 people and we were all game designers. It was a school project @ Isart Digital Paris done in the third year. 
               <br>
               One of them focused more on the documentation, another on the animations and I focused on the development.
            </p>
            <br>
            <p>
                The player has a movement set, some of them can be enhanced or unlocked when using their sword.
                Because of the possibilities of these moves (conditions, transitions, combos, context, ...) 
                I had to plan a robust system where planned moves could be defined in Blueprints and 
                future movements and tweaks/patches could be implemented without slow iterations.
            </p>
            <br>
            <h1>Tech solution for modular movements</h1>
            <p>
                The solution that rolled out quite well for us was a mix of State Trees, Blueprint definitions and fragments.
                <br>
                <br>
                <b>State Trees</b> were used as the authority for managing the states of the Player and the Sword (one for each).
                This comes really handy to control transitions between states, especially when you have runtime conditions that need to be executed.
                <br>
                <br>
                <b>Blueprints</b> definitions were used to define a Player/Sword movement (one BP per move).
                Those Blueprint are then referenced in the State Tree to be instantiated at runtime.
                <br>
                <br>
                And finally, in these Blueprints <b>fragments</b> were used to allow modular moves. Which is great for iterating and avoiding hardcoded situations.
            </p>
            <br>
            <br>
            <div class="img-container">
                <p>Player State Tree</p>
                <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_PlayerStateTree.png">
            </div>
            <br>
            <div class="img-container">
                <p>Sword State Tree</p>
                <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordStateTree.png">
            </div>
            <br>
            <p>
                It may be at first annoying to have to work with dozens of Blueprints to have a few moves, but it was mandatory for fast iterations with source control.
                <br>
                If the moves and the parameters were on the State Tree tasks, anytime someone wanted to work on a move, no one could work as the whole State Tree asset would have been checked out.
                <br>
                With multiple Blueprints, each designer can work on a set of moves without bothering others.
            </p>
            <br>
            <h1>Player Movements</h1>
            <p>
                For the player movements, fragments are the main source of behaviors. Some of them work in standalone while others can be queried/query other fragments to get extra data (for example the Anim Montage fragment can query the Duration fragment to dynamically change the play rate to fit).
                <br>
                <br>
                A few examples of fragments are:
                <br>
                - Editing the player speed
                <br>
                - Changing camera properties
                <br>
                - Sending a State Tree event to the sword State Tree
                <br>
                - Playing anim montages
                <br>
                - Running external Blueprints called "Scripts", mainly used for more game feel effects like camera shakes or flow logic like switching to another player move/state
                <br>
                - Changing gravity, locking moving direction and more
            </p>
            <br>
            <div class ="img-container-vert">
                <div class="img-container">
                    <p>Player Dash Movement</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDance_DevScreen_ExamplePlayerMove1.png">
                </div>
                <div class="img-container">
                    <p>Player Dash External Script Movement</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDance_DevScreen_ExamplePlayerMoveScript1.png">
                </div>
            </div>
            <br>
            <h1>Sword Movements</h1>
            <p>
                The sword moves using physics. For custom contextual actions such as the sword dash we use sequencers.
                <br>
                Sword movements have similarities with the player movement system, but they are quite different.
                <br>
                <br>
                First off, the Sword Movement Component can run 2 types of sword movements at the same time: a Movement Behavior and a Rotation Behavior.
                Sometimes a sword move will have both needed and in rare cases only one of them will be running.
                <br>
                These sword behavior Blueprints are based on a mix of fragments and subclasses.
                <br>
                <br>
                The Movement and Rotation behaviors classes have a few subclasses.
                <br>
                For example, the movement behavior base class contains data such as the move speed, and subclasses add extra rules, for example what sequencer to play or what is the target location.
                The rotation behavior is quite similar, it handles rotation speed and target look direction.
                <br>
                In our system sequencers are played from the movement behavior since I decided they will have authority on the rotation behavior in those cases.
                <br>
                <br>
            </p>
            <div style="text-align:center">
                <p><b>Examples of sword behaviors.</b></p>
            </div>
            <br>
            <div class="img-container-vert">
                <div class="img-container">
                    <p>Sword Follow Player Movement Behavior</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordFollowMove.png">
                </div>
                <div class="img-container">
                    <p>Sword Follow Player Rotation Behavior</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordFollowRot.png">
                </div>
                <div class="img-container">
                    <p>Sword Slash Enhanced Movement Behavior</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordSlashSeq.png">
                </div>
            </div>
            <br>
            <p>
                Sword behaviors also have 2 more important sections: the "Transition" and "Player Event Container". These are usually used for the movement behaviors.
                <br>
                The Transition section is for moves that require the sword to do something before running the behavior, for example teleportation to match the move start location for the upcoming sequencer.
                <br>
                The Player Event Container is for behaviors that need to send a special event to the player. For example an anim montage to run. 
            </p>
            <br>
            <div>
                <div class="img-container">
                    <p>Sword Ground Dash Movement Behavior (Transition section)</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordDashTransition.png" style="height:100px">
                </div>
            <br>
                <div class="img-container">
                    <p>Sword Slash Movement Behavior (Player Event Container)</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordSlash.png">
                </div>
            <br>
                <div class="img-container">
                    <p>Sword Recall Movement Behavior (Both used)</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SwordRecall.png">
                </div>
            </div>
            <br>
            <h1>Sequencer</h1>
            <p>
                As previously mentioned we use level sequencers (unlike the name the level sequencers we used are abstract and can be used in any level).
                <br>
                These sequencers use dynamic bindings to get the player character and sword to override their animations, transforms and so on to have perfectly synced moves with high precision.
                <br>
                <br>
                To allow more customization and feedback, sequences can have events on the tracks, which can edit gameplay.
                For example, some moves execute other ones at the end with dynamic branching.
                Others disable move input temporarily or apply a player boost.
            </p>
            <br>
            <div class="img-container">
                <p>Sword Enhanced Slash Sequencer</p>
                <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_SlashSequencer.png">
            </div>
            <br>
            <h1>Debugging</h1>
            <p>
                Being able to debug a complex system like this one is mandatory.
                <br>
                For the states, this is handled by the very nice State Tree debugger.
                <br>
                For the player movements and sword behaviors I created a handful of console commands. If I had more time I would have integrated the system inside the rewind debugger for an even better experience.
            </p>
            <br>
            <div class="img-container-vert">
                <div class="img-container">
                    <p>Console Commands</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_Console.png">
                </div>
                <div class="img-container">
                    <p>Player and Sword debugging</p>
                    <img class="default" src="../../../data/img/DevScreen/SwordDancer_DevScreen_DebugTexts.png">
                </div>
            </div>
            <br>
            <br>
            <p>
                To conclude, I will say that this project was a very interesting one to work on. 
                <br>
                The technical challenges were intersting and if I had to work again on a project like this I would keep 
                the same tech solution while changing the parts that weren't the best choices but had to be kept to be able to release a build.
            </p>
            <br>
            <br>
            <p>Thanks for reading.</p>
        </div>
        
    </div>
    
    <div id="footer"></div>
    
    <script>
        EndFile();
    </script>
    </body>
</html>
